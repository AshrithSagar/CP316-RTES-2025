\section*{Part B}

Describe synchronization mechanisms for the following:
\begin{itemize}[noitemsep, topsep=0pt]
    \item Receiving audio samples
    \item Receiving echo pulse for the ultrasonic sensor
    \item Sending debug messages over the radio link.
\end{itemize}

\subsection*{Solution}

\subsubsection*{Acquisition of audio samples}

The \texttt{16}-bit ADC fires interrupts at \( 32\,\texttt{kHz} \), which gives one sample per interrupt.
The given black box voice command detection algorithm processes windows of \texttt{32\,ms} of these samples and writes them to a buffer.
Once there is enough data in the buffer to process, the algorithm is able to make a decision, which in this case is given as requiring 4 consecutive windows.
Since the samples are no longer required after passing the window, using a \textit{circular buffer} here to store the samples makes sense.
Naively allocating the buffer length to be 4 times the number of samples in one window should work, but since it is given that the algorithm executes in about \texttt{8\,ms}--\texttt{12\,ms}, which is less than \texttt{32\,ms}, so it sufficies to keep the length of this buffer to be twice the number of samples in one window.
The length required for such a buffer can then be calculated as \( 2 \times 8\,\cancel{\texttt{kHz}} \times 32\,\cancel{\texttt{ms}} = 512 \).

We can see that this scenario is the classical case of the producer-consumer problem, so to synchronise between them, a message queue can be used, where the buffer is set as described above, and message queue's semaphore can be used to signal the producer (the ADC) and the consumer (the black box algorithm).
The producer will signal the semaphore when it has written a new sample to the buffer, and the consumer will wait on the semaphore until it has enough samples to process, which in this case is the number of samples in one window (256).

\subsubsection*{Ultrasonic echo measurements}

A timer callback periodically triggers the ultrasonic sensor to send out a pulse.
When the echo pin goes high and the ISR starts a timer, and the system is not free to process other tasks.
When the echo pin goes low upon receiving an incoming pulse, the interrupt handler stops the timer and calculates the time taken for the echo to return, and in turn the distance to the obstacle, if any, in a separate task.

\subsubsection*{Transmission of debugging messages}
